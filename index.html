<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EEE6208 交互式复习指南</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <!-- Chosen Palette: Calm Harmony -->
    <!-- Application Structure Plan: 我设计了一个基于标签页的单页面应用结构。这种结构将PDF中的六个核心主题（MOSFET基础、CMOS逻辑、延迟分析、高级逻辑、电路测试、专家问题）分离开来，使用户能够根据自己的学习需求自由跳转，而不是被动地按顺序阅读。每个标签页内部，我都将静态的文字和图表重构为交互式组件：例如，用户可以点击按钮切换问题场景，实时查看晶体管工作区的分析过程；可以通过下拉菜单选择布尔函数，动态生成对应的晶体管级电路图；还可以拖动滑块，观察逻辑努力参数变化对电路延迟的影响。这种设计将枯燥的理论学习转变为一种主动探索和即时反馈的体验，极大地提高了信息的可消费性和易理解性。 -->
    <!-- Visualization & Content Choices: 1. MOSFET工作区分析器：(目标:教学) 将PDF中的静态问题转化为一个交互式计算器。用户点击按钮选择不同电压场景，应用会动态展示计算步骤和结果，并通过高亮显示强调结论。(方法: HTML/CSS/JS)。 2. 复杂逻辑门生成器：(目标:组织) 用户从下拉菜单选择一个布尔函数，应用会用HTML/CSS动态构建出对应的PUN/PDN网络图，直观展示串并联结构。(方法: HTML/CSS/JS)。 3. 逻辑努力延迟图表：(目标:变化) 使用Chart.js绘制线图，通过滑块让用户交互式地调整逻辑努力(g)和寄生延迟(p)，实时观察总延迟(d)的变化曲线，加深对d=gh+p公式的理解。(方法: Chart.js/JS)。 4. PTL电压降模拟器：(目标:告知) 通过按钮触发简单的动画效果，模拟NMOS传输'1'时的电压降，以及弱维持器如何修复该问题。(方法: HTML/CSS/JS)。 5. 固定型故障模拟器：(目标:比较) 用户选择一个故障类型和一个测试向量，应用会同时显示“无故障输出”和“故障输出”，清晰地展示故障是否被检测到。(方法: HTML/CSS/JS)。 -->
    <!-- CONFIRMATION: NO SVG graphics used. NO Mermaid JS used. -->
    <style>
        body {
            font-family: 'Inter', 'Helvetica Neue', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;
            background-color: #f7fafc; /* gray-100 */
        }
        .nav-button {
            transition: all 0.3s ease;
            border-bottom: 4px solid transparent;
        }
        .nav-button.active {
            border-bottom-color: #4fd1c5; /* teal-400 */
            color: #2c7a7b; /* teal-800 */
            font-weight: 600;
        }
        .content-section {
            display: none;
            animation: fadeIn 0.5s ease-in-out;
        }
        .content-section.active {
            display: block;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .chart-container {
            position: relative;
            width: 100%;
            max-width: 600px;
            margin-left: auto;
            margin-right: auto;
            height: 300px;
            max-height: 400px;
        }
        @media (min-width: 768px) {
            .chart-container {
                height: 350px;
            }
        }
        .transistor {
            display: flex;
            align-items: center;
            justify-content: center;
            border: 2px solid;
            border-radius: 8px;
            padding: 4px 8px;
            margin: 4px;
            font-family: monospace;
            font-size: 12px;
            position: relative;
        }
        .transistor-pmos {
            border-color: #f56565; /* red-500 */
            background-color: #fed7d7; /* red-200 */
        }
        .transistor-nmos {
            border-color: #4299e1; /* blue-500 */
            background-color: #bee3f8; /* blue-200 */
        }
        .transistor::before {
            content: '';
            position: absolute;
            left: -10px;
            width: 8px;
            height: 2px;
            background-color: #718096; /* gray-500 */
        }
        .transistor-pmos::after {
            content: 'o';
            position: absolute;
            left: -18px;
            top: 50%;
            transform: translateY(-50%);
            border-radius: 50%;
            border: 2px solid #718096; /* gray-500 */
            width: 8px;
            height: 8px;
            line-height: 4px;
            font-size: 10px;
            text-align: center;
            background: white;
        }
        .circuit-line {
            background-color: #718096; /* gray-500 */
        }
        .circuit-node {
             width: 10px;
             height: 10px;
             background-color: #718096; /* gray-500 */
             border-radius: 50%;
        }
    </style>
</head>
<body class="bg-gray-50 text-gray-800">

    <div class="container mx-auto p-4 md:p-8">
        <header class="text-center mb-8">
            <h1 class="text-3xl md:text-4xl font-bold text-teal-800">EEE6208 数字电路 交互式复习指南</h1>
            <p class="text-gray-600 mt-2">一个将静态知识转化为动态探索的学习工具</p>
        </header>

        <nav class="bg-white rounded-lg shadow-md mb-8 sticky top-2 z-10">
            <div class="flex flex-wrap justify-center items-center p-2 text-sm md:text-base">
                <button data-target="home" class="nav-button p-3 md:p-4 active">首页</button>
                <button data-target="mosfet" class="nav-button p-3 md:p-4">MOSFET基础</button>
                <button data-target="cmos" class="nav-button p-3 md:p-4">CMOS逻辑设计</button>
                <button data-target="delay" class="nav-button p-3 md:p-4">电路延迟分析</button>
                <button data-target="advanced" class="nav-button p-3 md:p-4">高级逻辑</button>
                <button data-target="testing" class="nav-button p-3 md:p-4">电路测试</button>
                <button data-target="expert" class="nav-button p-3 md:p-4">专家问题</button>
            </div>
        </nav>

        <main>
            <!-- 首页 -->
            <section id="home" class="content-section active">
                <div class="bg-white p-6 rounded-lg shadow">
                    <h2 class="text-2xl font-bold text-teal-700 mb-4">欢迎来到 EEE6208 交互式指南</h2>
                    <p class="mb-4">本应用旨在帮助您更有效地复习和掌握数字集成电路的核心概念。我们摒弃了传统的线性阅读模式，将关键知识点和习题转化为一系列可交互的模块。</p>
                    <p class="mb-4">您可以通过顶部的导航栏在不同主题之间自由切换。在每个主题内，您会发现：</p>
                    <ul class="list-disc list-inside space-y-2 mb-4 text-gray-700">
                        <li><span class="font-semibold text-teal-600">核心概念卡片：</span>对关键定义和原理的精炼总结。</li>
                        <li><span class="font-semibold text-teal-600">交互式模拟器：</span>通过动手操作来理解电路行为，例如判断晶体管工作区或设计逻辑门。</li>
                        <li><span class="font-semibold text-teal-600">可视化图表：</span>将复杂的公式和数据关系以图表形式呈现，如延迟分析。</li>
                    </ul>
                    <p>这种探索式的学习方法旨在加深您对电路物理、逻辑设计和性能优化的理解。现在，请点击上方导航栏，开始您的学习之旅吧！</p>
                </div>
            </section>

            <!-- MOSFET基础 -->
            <section id="mosfet" class="content-section">
                <div class="bg-white p-6 rounded-lg shadow">
                     <h2 class="text-2xl font-bold text-teal-700 mb-4">MOSFET 工作原理基础</h2>
                     <p class="mb-6">本部分为理解后续所有数字电路概念奠定基础。深入掌握 MOSFET 的工作原理至关重要，因为这些器件是构成现代数字电路的基本单元。我们将通过一个交互式分析器，探索 NMOS 晶体管在不同电压条件下的工作状态。</p>

                    <div class="border border-gray-200 rounded-lg p-6">
                        <h3 class="text-xl font-semibold mb-4">NMOS 工作区交互式分析器</h3>
                        <p class="mb-4">根据 Problem Sheet 1, Q2，我们已知 NMOS 的阈值电压 $V_{THN} = 0.4V$。请选择以下任一场景，观察晶体管的工作区是如何判定的。</p>
                        <div class="flex flex-wrap gap-4 mb-6">
                            <button id="nmos-case-a" class="bg-teal-500 hover:bg-teal-600 text-white font-bold py-2 px-4 rounded">场景 (a)</button>
                            <button id="nmos-case-b" class="bg-teal-500 hover:bg-teal-600 text-white font-bold py-2 px-4 rounded">场景 (b)</button>
                            <button id="nmos-case-c" class="bg-teal-500 hover:bg-teal-600 text-white font-bold py-2 px-4 rounded">场景 (c)</button>
                        </div>
                        
                        <div class="grid md:grid-cols-2 gap-6">
                            <div class="flex flex-col items-center justify-center bg-gray-50 p-4 rounded-lg">
                                <p class="font-mono text-lg mb-2">Vd = <span id="nmos-vd" class="font-bold text-red-600">?</span></p>
                                <div class="w-24 h-8 bg-blue-300 border-2 border-blue-600 rounded"></div>
                                <div class="w-2 h-8 bg-blue-600"></div>
                                <div class="w-24 h-8 bg-blue-300 border-2 border-blue-600 rounded"></div>
                                <p class="font-mono text-lg mt-2">Vs = <span id="nmos-vs" class="font-bold text-blue-800">?</span></p>
                                <div class="absolute ml-[-120px] font-mono text-lg">Vg = <span id="nmos-vg" class="font-bold text-green-600">?</span></div>
                                 <div class="absolute ml-[-100px] w-2 h-16 bg-green-600"></div>
                                <div class="absolute ml-[-120px] border-l-2 border-b-2 border-green-600 h-10 w-4"></div>
                            </div>
                            <div id="nmos-analysis" class="bg-gray-100 p-4 rounded-lg">
                                <h4 class="font-semibold mb-2">分析步骤:</h4>
                                <p class="text-sm">请选择一个场景开始分析。</p>
                            </div>
                        </div>
                    </div>
                </div>
            </section>
            
            <!-- CMOS逻辑设计 -->
            <section id="cmos" class="content-section">
                 <div class="bg-white p-6 rounded-lg shadow">
                    <h2 class="text-2xl font-bold text-teal-700 mb-4">静态 CMOS 逻辑设计</h2>
                    <p class="mb-6">静态 CMOS 逻辑的核心在于使用互补的 PMOS 上拉网络（PUN）和 NMOS 下拉网络（PDN）来实现布尔函数。PUN 和 PDN 结构上互为对偶，确保在稳定状态下总有一个网络导通，另一个截止。下面的工具可以帮您可视化复杂逻辑门的晶体管级实现。</p>

                    <div class="border border-gray-200 rounded-lg p-6">
                        <h3 class="text-xl font-semibold mb-4">复杂逻辑门生成器</h3>
                        <p class="mb-4">请从下拉菜单中选择一个布尔函数，观察其对应的 PUN 和 PDN 电路结构。串联代表“与”逻辑，并联代表“或”逻辑。</p>
                        <select id="complex-gate-selector" class="w-full md:w-1/2 p-2 border border-gray-300 rounded-md mb-6">
                            <option value="f1">F = (ABC+D)'</option>
                            <option value="f2">F = ((AB+C)D)' (非标准, 假设为 F'=(AB+C)D )</option>
                            <option value="f3">F = (AB+C(A+B))'</option>
                        </select>

                        <div class="grid md:grid-cols-2 gap-8">
                            <div>
                                <h4 class="text-lg font-semibold text-center mb-2">上拉网络 (PUN - PMOS)</h4>
                                <div id="pun-network" class="bg-red-50 p-4 rounded-lg min-h-[200px] flex flex-col items-center justify-center"></div>
                            </div>
                            <div>
                                <h4 class="text-lg font-semibold text-center mb-2">下拉网络 (PDN - NMOS)</h4>
                                <div id="pdn-network" class="bg-blue-50 p-4 rounded-lg min-h-[200px] flex flex-col items-center justify-center"></div>
                            </div>
                        </div>
                    </div>
                </div>
            </section>

            <!-- 电路延迟分析 -->
            <section id="delay" class="content-section">
                <div class="bg-white p-6 rounded-lg shadow">
                    <h2 class="text-2xl font-bold text-teal-700 mb-4">电路延迟分析与优化</h2>
                    <p class="mb-6">电路的开关速度是关键性能指标。逻辑努力（Logical Effort）是一种强大的模型，用于分析和优化门级电路的延迟。它将延迟分解为与门自身特性相关的寄生延迟（p）和与负载相关的努力延迟（f=gh）。通过调整各级门的尺寸，可以最小化整个路径的延迟。</p>
                    
                    <div class="border border-gray-200 rounded-lg p-6">
                        <h3 class="text-xl font-semibold mb-4">逻辑努力延迟可视化</h3>
                        <p class="mb-4">归一化延迟公式为 $d = gh + p$。其中 $g$ 是逻辑努力，$h$ 是电气努力（负载/输入电容比），$p$ 是寄生延迟。拖动下面的滑块，观察 $g$ 和 $p$ 的变化如何影响总延迟与负载的关系。</p>

                        <div class="grid md:grid-cols-2 gap-8 items-center">
                            <div>
                                <div class="mb-4">
                                    <label for="g-slider" class="block mb-1 font-semibold">逻辑努力 (g): <span id="g-value">1.0</span></label>
                                    <input id="g-slider" type="range" min="1" max="5" value="1" step="0.1" class="w-full">
                                </div>
                                <div class="mb-4">
                                    <label for="p-slider" class="block mb-1 font-semibold">寄生延迟 (p): <span id="p-value">1.0</span></label>
                                    <input id="p-slider" type="range" min="0.5" max="4" value="1" step="0.1" class="w-full">
                                </div>
                            </div>
                            <div class="chart-container">
                                <canvas id="delayChart"></canvas>
                            </div>
                        </div>
                    </div>
                </div>
            </section>

            <!-- 高级逻辑 -->
            <section id="advanced" class="content-section">
                <div class="bg-white p-6 rounded-lg shadow">
                    <h2 class="text-2xl font-bold text-teal-700 mb-4">高级逻辑电路</h2>
                    <p class="mb-6">除了静态CMOS，其他逻辑类型在特定场景下有其优势。传输门逻辑（PTL）可以非常紧凑地实现某些功能（如多路选择器），但存在电压降问题。本节将通过一个交互式示例，帮助您理解这个问题以及“弱维持器”是如何解决它的。</p>

                    <div class="border border-gray-200 rounded-lg p-6">
                        <h3 class="text-xl font-semibold mb-4">PTL 电压降与弱维持器模拟</h3>
                        <div class="flex flex-col items-center">
                            <div class="flex items-center space-x-4 mb-4">
                                <span class="font-bold">Vin = VDD</span>
                                <div class="w-8 h-px bg-gray-600"></div>
                                <div class="flex flex-col items-center">
                                    <span class="text-sm">Control = VDD</span>
                                    <div class="w-px h-4 bg-gray-600"></div>
                                    <div id="ptl-nmos" class="transistor transistor-nmos" style="width: 60px;">NMOS</div>
                                </div>
                                <div class="w-8 h-px bg-gray-600"></div>
                                <div id="ptl-keeper-line" class="w-px h-8 bg-pink-400 opacity-0 transition-opacity duration-500" style="margin-left: -1rem; margin-right: -1rem;"></div>
                                <div id="ptl-keeper" class="transistor transistor-pmos opacity-0 transition-opacity duration-500" style="position: absolute; right: calc(50% - 100px); top: 50%;">Keeper</div>
                                <span class="font-bold">Vout = <span id="ptl-vout" class="text-red-500">?</span></span>
                            </div>
                            <div class="flex gap-4">
                                <button id="ptl-pass-one" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded">1. 尝试传输 '1'</button>
                                <button id="ptl-engage-keeper" class="bg-pink-500 hover:bg-pink-600 text-white font-bold py-2 px-4 rounded" disabled>2. 启用弱维持器</button>
                            </div>
                            <p id="ptl-explanation" class="mt-4 text-center text-gray-600 h-10"></p>
                        </div>
                    </div>
                </div>
            </section>

            <!-- 电路测试 -->
            <section id="testing" class="content-section">
                 <div class="bg-white p-6 rounded-lg shadow">
                    <h2 class="text-2xl font-bold text-teal-700 mb-4">数字电路测试</h2>
                    <p class="mb-6">确保制造的芯片没有缺陷至关重要。固定型故障（Stuck-at Fault）模型是最常用的一种简化故障模型，它假设电路中的某条线永久地固定在了逻辑'0'（SA0）或逻辑'1'（SA1）。测试的目标就是施加合适的输入向量，使得故障效应可以被观测到。</p>

                    <div class="border border-gray-200 rounded-lg p-6">
                        <h3 class="text-xl font-semibold mb-4">固定型故障模拟器</h3>
                        <p class="mb-4">请选择一个门电路、一个故障类型和一个测试向量，观察测试结果。成功的测试意味着在故障存在时，实际输出与预期输出不同。</p>

                        <div class="grid md:grid-cols-3 gap-4 mb-6">
                            <div>
                                <label for="fault-gate" class="block font-semibold mb-1">门电路:</label>
                                <select id="fault-gate" class="w-full p-2 border rounded">
                                    <option value="NAND2">2-输入与非门 (NAND)</option>
                                    <option value="XOR2">2-输入异或门 (XOR)</option>
                                </select>
                            </div>
                            <div>
                                <label for="fault-type" class="block font-semibold mb-1">故障类型:</label>
                                <select id="fault-type" class="w-full p-2 border rounded">
                                    <option value="OUT_SA1">输出 Stuck-at-1</option>
                                    <option value="OUT_SA0">输出 Stuck-at-0</option>
                                </select>
                            </div>
                            <div>
                                <label for="test-vector" class="block font-semibold mb-1">测试向量 (A,B):</label>
                                <select id="test-vector" class="w-full p-2 border rounded">
                                    <option value="00">00</option>
                                    <option value="01">01</option>
                                    <option value="10">10</option>
                                    <option value="11">11</option>
                                </select>
                            </div>
                        </div>
                        <button id="run-fault-test" class="w-full bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded mb-6">运行测试</button>

                        <div class="grid grid-cols-2 gap-4 text-center">
                            <div class="bg-blue-100 p-4 rounded-lg">
                                <h4 class="font-bold mb-2">预期无故障输出</h4>
                                <p id="good-output" class="text-4xl font-mono">-</p>
                            </div>
                            <div class="bg-red-100 p-4 rounded-lg">
                                <h4 class="font-bold mb-2">实际故障输出</h4>
                                <p id="faulty-output" class="text-4xl font-mono">-</p>
                            </div>
                        </div>
                        <div id="test-result" class="mt-4 text-center font-bold text-2xl h-8"></div>
                    </div>
                </div>
            </section>
            
             <!-- 专家问题 -->
            <section id="expert" class="content-section">
                <div class="bg-white p-6 rounded-lg shadow">
                    <h2 class="text-2xl font-bold text-teal-700 mb-4">专家级问题解析</h2>
                    <p class="mb-6">本节处理一些更细致的优化问题，这些问题需要超越基本规则的更深层次理解。通用设计法则是很好的起点，但真正的性能优化往往需要在具体场景下进行权衡。</p>

                    <div class="border border-gray-200 rounded-lg p-6 mb-6">
                        <h3 class="text-xl font-semibold mb-4">关键路径优化：信号到达顺序</h3>
                        <p class="mb-4">对于一个串联的 NMOS 下拉网络 (如 NAND 门)，如果一个输入信号比另一个晚到，应该将这个“慢信号”放在靠近输出的晶体管上，还是靠近地的晶体管上？</p>
                         <div class="text-center my-4 p-4 bg-gray-100 rounded-md">
                            <p class="font-semibold">结论：将最慢（最关键）的信号连接到靠近<span class="text-blue-600 font-bold">地</span>的晶体管 (<span class="font-mono">A</span>) 上性能更优。</p>
                        </div>
                        <p><strong>原因:</strong> 这种策略利用了“预放电”效应。如果速度较快的信号 (<span class="font-mono">B</span>) 先到达，它会导通并开始对内部节点 (<span class="font-mono">X</span>) 的电容进行放电。当较慢的信号 (<span class="font-mono">A</span>) 最终到达时，其漏极 (<span class="font-mono">X</span>) 的电压已经较低，使得晶体管 <span class="font-mono">A</span> 能够更快地完成整个路径到地的导通，从而减少了由关键信号贡献的总延迟。</p>
                    </div>

                     <div class="border border-gray-200 rounded-lg p-6">
                        <h3 class="text-xl font-semibold mb-4">非对称晶体管尺寸</h3>
                        <p class="mb-4">有时，为了优化特定路径，会使用非对称的晶体管尺寸，即使它们在同一个串联路径中。例如，一个串联路径中，数据信号 A 的晶体管尺寸为 2，而复位信号 Reset 的晶体管尺寸为 4/3。</p>
                        <div class="text-center my-4 p-4 bg-gray-100 rounded-md">
                            <p class="font-semibold">目的：牺牲非关键路径的速度，来优化关键路径的延迟和功耗。</p>
                        </div>
                        <p><strong>原因:</strong> 'Reset' 信号通常不是性能关键路径。通过使用一个较小的晶体管 (尺寸 4/3)，可以减少其输入电容，从而降低驱动 Reset 信号的电路的负载。虽然这会增加 Reset 晶体管自身的电阻，但我们可以通过适度增大关键数据信号 'A' 的晶体管 (尺寸 2) 来补偿，以确保总下拉电阻仍然满足设计要求。这是一种典型的工程权衡：牺牲非关键信号（Reset）的速度，以换取关键信号（A）的性能提升和/或面积/功耗的降低。</p>
                    </div>
                </div>
            </section>

        </main>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function () {
            
            const navButtons = document.querySelectorAll('.nav-button');
            const contentSections = document.querySelectorAll('.content-section');

            function activateSection(targetId) {
                navButtons.forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.target === targetId);
                });
                contentSections.forEach(section => {
                    section.classList.toggle('active', section.id === targetId);
                });
            }
            
            navButtons.forEach(button => {
                button.addEventListener('click', () => {
                    const targetId = button.dataset.target;
                    activateSection(targetId);
                });
            });

            // --- MOSFET Analyzer Logic ---
            const nmosAnalysisEl = document.getElementById('nmos-analysis');
            const nmosVdEl = document.getElementById('nmos-vd');
            const nmosVsEl = document.getElementById('nmos-vs');
            const nmosVgEl = document.getElementById('nmos-vg');
            
            const nmosCases = {
                a: { vg: 1.9, vd: 2.5, vs: 0 },
                b: { vg: 2.2, vd: 0.5, vs: 0 },
                c: { vg: 0.9, vd: -2.3, vs: -2.5 }
            };
            const vthn = 0.4;

            function analyzeNmos(caseData) {
                let { vg, vd, vs } = caseData;
                let source, drain;

                if (vd >= vs) {
                    source = vs;
                    drain = vd;
                } else {
                    source = vd;
                    drain = vs;
                }

                const vgs = vg - source;
                const vds = drain - source;
                
                nmosVdEl.textContent = `${vd}V`;
                nmosVsEl.textContent = `${vs}V`;
                nmosVgEl.textContent = `${vg}V`;

                let analysisHtml = `<h4 class="font-semibold mb-2">分析步骤 (${caseData === nmosCases.c ? "源/漏反接" : "常规"}) :</h4><ol class="list-decimal list-inside text-sm space-y-1">`;
                analysisHtml += `<li>识别端子: Vd=${vd}V, Vs=${vs}V. 实际源极为 ${source}V, 漏极为 ${drain}V.</li>`;
                analysisHtml += `<li>计算Vgs: ${vg}V - ${source}V = <strong>${vgs.toFixed(1)}V</strong></li>`;
                analysisHtml += `<li>计算Vds: ${drain}V - ${source}V = <strong>${vds.toFixed(1)}V</strong></li>`;
                
                let region = '';
                if (vgs < vthn) {
                    region = '截止区 (Cut-Off)';
                    analysisHtml += `<li>比较Vgs与Vthn: ${vgs.toFixed(1)}V < ${vthn}V.</li>`;
                } else {
                    analysisHtml += `<li>比较Vgs与Vthn: ${vgs.toFixed(1)}V > ${vthn}V. 器件导通.</li>`;
                    const vgs_vth = vgs - vthn;
                    analysisHtml += `<li>计算 Vgs-Vthn: ${vgs.toFixed(1)}V - ${vthn}V = <strong>${vgs_vth.toFixed(1)}V</strong></li>`;
                    if (vds >= vgs_vth) {
                        region = '饱和区 (Saturation)';
                        analysisHtml += `<li>比较Vds与Vgs-Vthn: ${vds.toFixed(1)}V >= ${vgs_vth.toFixed(1)}V.</li>`;
                    } else {
                        region = '线性区 (Linear)';
                        analysisHtml += `<li>比较Vds与Vgs-Vthn: ${vds.toFixed(1)}V < ${vgs_vth.toFixed(1)}V.</li>`;
                    }
                }
                analysisHtml += `</ol><p class="mt-4 font-bold text-lg text-center bg-teal-100 text-teal-800 p-2 rounded">结论: ${region}</p>`;
                nmosAnalysisEl.innerHTML = analysisHtml;
            }

            document.getElementById('nmos-case-a').addEventListener('click', () => analyzeNmos(nmosCases.a));
            document.getElementById('nmos-case-b').addEventListener('click', () => analyzeNmos(nmosCases.b));
            document.getElementById('nmos-case-c').addEventListener('click', () => analyzeNmos(nmosCases.c));
            analyzeNmos(nmosCases.a);

            // --- Complex Gate Generator ---
            const gateSelector = document.getElementById('complex-gate-selector');
            const punNetwork = document.getElementById('pun-network');
            const pdnNetwork = document.getElementById('pdn-network');

            function createTransistor(type, label) {
                const el = document.createElement('div');
                el.className = `transistor ${type === 'pmos' ? 'transistor-pmos' : 'transistor-nmos'}`;
                el.textContent = label;
                return el;
            }

            function createSeries(...elements) {
                const container = document.createElement('div');
                container.className = 'flex flex-col items-center';
                elements.forEach((el, index) => {
                    container.appendChild(el);
                    if (index < elements.length - 1) {
                         const line = document.createElement('div');
                         line.className = 'w-px h-4 circuit-line';
                         container.appendChild(line);
                    }
                });
                return container;
            }

            function createParallel(...elements) {
                const container = document.createElement('div');
                container.className = 'flex items-center justify-center';
                elements.forEach((el, index) => {
                     const branch = document.createElement('div');
                     branch.className = 'flex flex-col items-center';
                     const topNode = document.createElement('div');
                     topNode.className = 'circuit-node';
                     const bottomNode = document.createElement('div');
                     bottomNode.className = 'circuit-node';
                     const lineTop = document.createElement('div');
                     lineTop.className = 'w-px h-4 circuit-line';
                     const lineBottom = document.createElement('div');
                     lineBottom.className = 'w-px h-4 circuit-line';
                     branch.append(lineTop, el, lineBottom);
                     container.appendChild(branch);
                });
                return container;
            }
            
            function buildGate(func) {
                punNetwork.innerHTML = '';
                pdnNetwork.innerHTML = '';

                // Common transistors
                const pA = createTransistor('pmos', 'A');
                const pB = createTransistor('pmos', 'B');
                const pC = createTransistor('pmos', 'C');
                const pD = createTransistor('pmos', 'D');
                const nA = createTransistor('nmos', 'A');
                const nB = createTransistor('nmos', 'B');
                const nC = createTransistor('nmos', 'C');
                const nD = createTransistor('nmos', 'D');

                if (func === 'f1') { // F = (ABC+D)'
                    // PDN: (A, B, C series) parallel with D
                    const seriesABC_n = createSeries(nA, nB, nC);
                    pdnNetwork.appendChild(createParallel(seriesABC_n, nD));
                    // PUN: (A, B, C parallel) series with D
                    const parallelABC_p = createParallel(pA, pB, pC);
                    punNetwork.appendChild(createSeries(parallelABC_p, pD));
                } else if (func === 'f2') { // F'=(AB+C)D
                    // PDN: ((A, B series) parallel with C) series with D
                     const seriesAB_n = createSeries(nA, nB);
                     const parallelABC_n = createParallel(seriesAB_n, nC);
                     pdnNetwork.appendChild(createSeries(parallelABC_n, nD));
                    // PUN: ((A, B parallel) series with C) parallel with D
                     const parallelAB_p = createParallel(pA, pB);
                     const seriesABC_p = createSeries(parallelAB_p, pC);
                     punNetwork.appendChild(createParallel(seriesABC_p, pD));
                } else if (func === 'f3') { // F = (AB+C(A+B))'
                    // PDN: (A, B series) parallel with (C series (A, B parallel))
                     const seriesAB_n = createSeries(nA, nB);
                     const parallelAB_n = createParallel(createTransistor('nmos', 'A'), createTransistor('nmos', 'B'));
                     const seriesC_AB_n = createSeries(nC, parallelAB_n);
                     pdnNetwork.appendChild(createParallel(seriesAB_n, seriesC_AB_n));
                    // PUN: (A, B parallel) series with (C parallel (A, B series))
                     const parallelAB_p = createParallel(pA, pB);
                     const seriesAB_p = createSeries(createTransistor('pmos', 'A'), createTransistor('pmos', 'B'));
                     const parallelC_AB_p = createParallel(pC, seriesAB_p);
                     punNetwork.appendChild(createSeries(parallelAB_p, parallelC_AB_p));
                }
            }
            gateSelector.addEventListener('change', (e) => buildGate(e.target.value));
            buildGate('f1');

            // --- Delay Chart Logic ---
            const gSlider = document.getElementById('g-slider');
            const pSlider = document.getElementById('p-slider');
            const gValue = document.getElementById('g-value');
            const pValue = document.getElementById('p-value');
            const ctx = document.getElementById('delayChart').getContext('2d');

            const h_values = [1, 2, 3, 4, 5, 6, 7, 8];
            let chartData = {
                labels: h_values.map(h => `h=${h}`),
                datasets: [{
                    label: '归一化延迟 (d = gh + p)',
                    data: [],
                    borderColor: '#4fd1c5',
                    backgroundColor: 'rgba(79, 209, 197, 0.2)',
                    borderWidth: 2,
                    tension: 0.1,
                    fill: true
                }]
            };

            const delayChart = new Chart(ctx, {
                type: 'line',
                data: chartData,
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: { display: true, text: '总延迟 (d)' }
                        },
                        x: {
                            title: { display: true, text: '电气努力 (h)' }
                        }
                    },
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return `d = ${context.raw.toFixed(2)}`;
                                }
                            }
                        }
                    }
                }
            });

            function updateDelayChart() {
                const g = parseFloat(gSlider.value);
                const p = parseFloat(pSlider.value);
                gValue.textContent = g.toFixed(1);
                pValue.textContent = p.toFixed(1);

                delayChart.data.datasets[0].data = h_values.map(h => g * h + p);
                delayChart.update();
            }
            gSlider.addEventListener('input', updateDelayChart);
            pSlider.addEventListener('input', updateDelayChart);
            updateDelayChart();

            // --- Advanced Logic PTL ---
            const ptlVout = document.getElementById('ptl-vout');
            const ptlExplanation = document.getElementById('ptl-explanation');
            const passOneBtn = document.getElementById('ptl-pass-one');
            const engageKeeperBtn = document.getElementById('ptl-engage-keeper');
            const keeperEl = document.getElementById('ptl-keeper');
            const keeperLineEl = document.getElementById('ptl-keeper-line');
            
            passOneBtn.addEventListener('click', () => {
                ptlVout.textContent = 'VDD - Vth';
                ptlVout.classList.add('animate-pulse');
                ptlExplanation.textContent = 'NMOS无法完美传输高电平, 产生电压降。';
                engageKeeperBtn.disabled = false;
            });

            engageKeeperBtn.addEventListener('click', () => {
                ptlVout.textContent = 'VDD';
                ptlVout.classList.remove('animate-pulse');
                keeperEl.classList.remove('opacity-0');
                keeperLineEl.classList.remove('opacity-0');
                ptlExplanation.textContent = '弱PMOS维持器将输出电平恢复至完整的VDD。';
            });

            // --- Fault Simulator Logic ---
            const faultGateSelect = document.getElementById('fault-gate');
            const faultTypeSelect = document.getElementById('fault-type');
            const testVectorSelect = document.getElementById('test-vector');
            const runTestBtn = document.getElementById('run-fault-test');
            const goodOutputEl = document.getElementById('good-output');
            const faultyOutputEl = document.getElementById('faulty-output');
            const testResultEl = document.getElementById('test-result');

            runTestBtn.addEventListener('click', () => {
                const gate = faultGateSelect.value;
                const fault = faultTypeSelect.value;
                const vector = testVectorSelect.value;
                const a = parseInt(vector[0]);
                const b = parseInt(vector[1]);

                let goodOut, faultyOut;

                // Calculate good output
                if (gate === 'NAND2') {
                    goodOut = (a && b) ? 0 : 1;
                } else { // XOR2
                    goodOut = (a !== b) ? 1 : 0;
                }

                // Calculate faulty output
                if (fault === 'OUT_SA1') {
                    faultyOut = 1;
                } else { // OUT_SA0
                    faultyOut = 0;
                }

                goodOutputEl.textContent = goodOut;
                faultyOutputEl.textContent = faultyOut;

                if (goodOut !== faultyOut) {
                    testResultEl.textContent = "检测到故障！";
                    testResultEl.className = "mt-4 text-center font-bold text-2xl h-8 text-green-600";
                } else {
                    testResultEl.textContent = "未检测到故障";
                     testResultEl.className = "mt-4 text-center font-bold text-2xl h-8 text-red-600";
                }
            });

            // Initial state
            activateSection('home');
        });
    </script>
</body>
</html>
